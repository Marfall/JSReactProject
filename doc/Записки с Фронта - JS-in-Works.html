Скрипты и время их выполнения:

Для запуска функции через определенное время;

setTimeOut(func, delay );     1- функция  2- задержка в ms 3 - далее возможны аргументы в функцию

function sayHello() {
	alert('Hello World!');
}

setTimeOut(sayHello, 3000);

let timerId = setTimeOut(sayHello, 3000);
clearTimeOut(timerId);  - используется для того чтобы остановить какой-то clearTimeOut

Для того чтобы скрипт повторясля через определенное количество времени,
сущесвует функция setInterval()

let timerId = setInterval(sayHello, 3000);
//clearTimeOut(timerId);

Чем рекурсивный setTimeOut лучше, чем setInterval?
-Дело в том, что когда таймер с интервалом работает, он не учитывает как долго
 будет работать функция внутри него (работа функции может оказаться дольше интервала)

 - Решение проблемы: рекурсивный setTimeOut

 - рекурсивный - значит функция вызывает сама себя

let timerId = setTimeout(function log(){
	console.log("Hello!");
	setTimeout(log, 2000);
});

Простейшая JS анимация:

let btn = document.querySelector('.btn'),	   - получаем кнопку для анимации
	elem = document.querySelector('.box');     - получаем квадрат для анимации

	function myAnimation() {
		let pos = 0;
		
		let id = setInterval(frame, 10);

		function frame() {
			if(pos == 300) {
				clearInterval();
			} else {
				pos++;
				elem.style.top = pos + 'px';   //изменение стилей и перемещение
				elem.style.left = pos + 'px';
			}
		}	
	}

	btn.addEventListener('click', myAnimation);

	Мы постепенно меняем свойства объекта, а для человека это выглядит как анимация
	Если кадров больше, чем 24 в секунду, то задержки мы не заметим
	В CCS3 можно манипулировать анимациями.
	

	Делегирование:

	Если мы хотим, чтобы на множестве кнопок вызывалось одно и то же событие,
	можно повесить событие на каждую кнопку, но есть проблема - если эти кнопки
	будет потом добавляться без нашего ведома, то событий у них уже не будет,
	ведь они не обработаются циклом, где назначаются обработчики. 
	
	let btnBlock = document.querySelector('.btn-block'),
		btns = document.getElementsByTagName('button');

	btnBlock.addEventListener('click', function(event){
		if(event.target && event.target.tagName = 'BUTTON') {   //если кликнуть на родителя ничего не произойдет
			console.log("Hello!");	
		}
	});	

	btnBlock.addEventListener('click', function(event){
		if(event.target && event.target.classList.contains('first')) {   // определенный класс кнопки
		}
	
	});	

	btnBlock.addEventListener('click', function(event){
		if(event.target && event.target.matches('button.first')) {   // ищем кнопку с определенным классом
			console.log("Hello!");	
		}
	
	});	

	Глобальные обработчики событий:

	window.addEventListener('load');       //load - выполнять скрипт только после полной загрузки страницы - с изображениями используется

	Самое важное для нас - чтобы было построено DOM-дерево

	window.addEventListener('DOMContentLoaded');   // DOMContentLoaded - срабатывает когда полностью загрузилась DOM-структура документа

	Есть несколько основных понятий JavaScript относительно человека:

	1) Document 
	
	2) Window - окно, в котором показывается документ,вкладки, плагины, адресная строка используется
		- то , через что просматриваем документы.
	
	3) Screen  - весь монитор

	ПОЛУЧЕНИЕ ПАРАМЕТРОВ ЭЛЕМЕНТОВ:

	let box = document.querySelector('.box');

	let width = box.clientWidth(),         //ширина контента без прокрутки и без бордера
		height = box.clientHeight();

	console.log(width);
	
	offsetWidth - и бордер, и пэддинг, и весь контент, и полосу прокрутки

	scrollWidth - ширина всего элемента с прокруткой(сама полоса прокрутки не берется)

	let btn = document.querySelector('button');

	btn.addEventListener('click', function() {
		box.style.height = box.scrollHeight + 'px';        //насильно устанавливаем полную высоту(раскрытие элемента со скроллом)
	});

	CallBack-функция , которая выполнится строго после первой(в нашем случае клика)

	Все эти параметры доступны только для чтения - можно только получить.

	scrollTop - то, что мы не видим сверху(то, что уже пролистали)

	btn.addEventListener('click', function(){
		box.scrollTop = 0;                       //прокрутка на самый верх (изменяемые)
	});

	getBoundingClientRect()  -- получить все координаты\

	box.getBoundingClientRect().right - получить отдельную координату элемента
	
	console.log(document.documentElement.clientWidth);   - весь документ

	console.log(document.documentElement.clientHeight); 

	scrollBy(x, y); - отмотать

	scrollTo(x, y); - переместит не относительно текущего положения, а на определенную координату.

	

	ТАЙМЕРЫ:

	let deadline = '2018-10-21';

	function getTimeReamaining(endtime) {
		let t = Date.parse(endtime) - Date.parse(new Date());
		seconds = Math.floor((t/1000) % 60),
		minutes = Math.floor((t/1000/60) % 60),
		hours = Math.floor((t/(1000*60*60)));
	}

	return {
		'total' : t,
		'hours' : hours,
		'minutes' : minutes,
		'seconds' : seconds
	};





















